{% extends "layout.twig" %}

{% block title %}Edit GIS Data - GIS Catalog{% endblock %}

{% block stylesheets %}
{{ parent() }}
    <!-- OpenLayers CSS -->
    <link rel="stylesheet" href="https://unpkg.com/ol@7.4.0/ol.css">
    <style>
        #map {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }
        .form-group {
            margin-bottom: 1rem;
            width: 100%;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            width: 100%;
        }
        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
        }
        .form-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            min-height: 100px;
            box-sizing: border-box;
        }
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
            background-color: white;
        }
        .form-checkbox {
            margin-right: 0.5rem;
        }
        .error-message {
            color: #dc2626;
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }
        .metadata-section {
            background-color: #f9fafb;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .required-field::after {
            content: " *";
            color: #dc2626;
        }
        /* Add table striping */
        .metadata-section:nth-child(odd) {
            background-color: #f3f4f6;
        }
        .metadata-section:nth-child(even) {
            background-color: #ffffff;
        }
        /* Make form elements consistent width */
        input[type="text"],
        input[type="url"],
        input[type="date"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
            font-size: 1rem;
            line-height: 1.5;
        }
        /* Add hover effect */
        .form-input:hover,
        .form-textarea:hover,
        .form-select:hover {
            border-color: #4b5563;
        }
        /* Add focus effect */
        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        /* Style section headers */
        .metadata-section h2 {
            color: #1f2937;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        /* Table styling for metadata fields */
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        .metadata-table th, .metadata-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .metadata-table tr:nth-child(odd) {
            background-color: #f3f4f6;
        }
        .metadata-table tr:nth-child(even) {
            background-color: #ffffff;
        }
        .metadata-table th {
            text-align: left;
            width: 25%;
            font-weight: 500;
        }
        .metadata-table td {
            width: 75%;
        }
    </style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <a href="/catalog" class="text-blue-600 hover:text-blue-900">&larr; Back to Catalog</a>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6">
        <h1 class="text-3xl font-bold mb-6">Edit GIS Data</h1>

        <form action="/catalog/{{ dataset.id }}/edit" method="POST" enctype="multipart/form-data" class="space-y-6">
            <!-- Metadata Standard -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">Metadata Standard</h2>
                
                <div class="form-group">
                    <label for="metadata_standard" class="form-label required-field">Metadata Standard</label>
                    <select id="metadata_standard" name="metadata_standard" class="form-select" required>
                        <option value="">Select a standard...</option>
                        <option value="ISO 19115" {% if dataset.metadata_standard == 'ISO 19115' %}selected{% endif %}>ISO 19115</option>
                        <option value="ISO 19139" {% if dataset.metadata_standard == 'ISO 19139' %}selected{% endif %}>ISO 19139</option>
                        <option value="INSPIRE" {% if dataset.metadata_standard == 'INSPIRE' %}selected{% endif %}>INSPIRE</option>
                        <option value="FGDC" {% if dataset.metadata_standard == 'FGDC' %}selected{% endif %}>FGDC</option>
                        <option value="OGC CSW" {% if dataset.metadata_standard == 'OGC CSW' %}selected{% endif %}>OGC CSW</option>
                        <option value="Dublin Core" {% if dataset.metadata_standard == 'Dublin Core' %}selected{% endif %}>Dublin Core</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="metadata_version" class="form-label required-field">Metadata Version</label>
                    <input type="text" id="metadata_version" name="metadata_version" 
                        class="form-input" value="{{ dataset.metadata_version|default('2018') }}" required>
                </div>
            </div>

            <!-- Thumbnail Upload -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">Thumbnail</h2>
                <div class="form-group">
                    {% if dataset.thumbnail_path %}
                        <div class="mb-4">
                            <img src="/assets/thumbnails/{{ dataset.thumbnail_path }}" alt="Current Thumbnail" style="max-width: 200px; max-height: 200px; border-radius: 8px; border: 1px solid #ccc;" />
                        </div>
                    {% endif %}
                    <label for="thumbnail" class="form-label">Upload Thumbnail (Image File)</label>
                    <input type="file" id="thumbnail" name="thumbnail" accept="image/*" class="form-input" />
                </div>
            </div>

            <!-- Dynamic Fields Container -->
            <div id="dynamicFields" class="space-y-6">
                <!-- Fields will be loaded here based on selected standard -->
            </div>

            <!-- Add is_public field (hidden + checkbox) before the submit button -->
            <div class="form-group">
                <input type="hidden" name="is_public" value="0">
                <label for="is_public" class="form-label">Publicly Visible?</label>
                <input type="checkbox" name="is_public" id="is_public" value="1" {% if dataset.is_public %}checked{% endif %}>
            </div>

            <div class="mt-6">
                <button type="submit" class="btn btn-primary">Save Changes</button>
                <a href="/catalog/{{ dataset.id }}" class="btn btn-secondary ml-4">Cancel</a>
            </div>
        </form>
    </div>
</div>

<script src="https://unpkg.com/ol@7.4.0/dist/ol.js"></script>
<script>
// Register EPSG:26713 projection
const proj26713 = new ol.proj.Projection({
    code: 'EPSG:26713',
    extent: [-5120900, -9998100, 9998100, 5120900],
    units: 'm'
});
ol.proj.addProjection(proj26713);

// Define the standard fields configuration
const standardFields = {
    'ISO 19115': {
        required: ['title', 'abstract', 'purpose', 'spatial_extent', 'temporal_extent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'purpose', label: 'Purpose', type: 'textarea', required: true },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatial_extent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'crsType', label: 'CRS Type', type: 'select', options: ['geographic', 'projected', 'vertical'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalStart', label: 'Start Date', type: 'date' },
                    { name: 'temporalEnd', label: 'End Date', type: 'date' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Responsible Parties',
                fields: [
                    { name: 'pointOfContactName', label: 'Point of Contact Name', type: 'text', required: true },
                    { name: 'pointOfContactOrg', label: 'Point of Contact Organization', type: 'text' },
                    { name: 'pointOfContactEmail', label: 'Point of Contact Email', type: 'text' },
                    { name: 'pointOfContactRole', label: 'Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'publisherName', label: 'Publisher Name', type: 'text' },
                    { name: 'publisherOrg', label: 'Publisher Organization', type: 'text' },
                    { name: 'publisherRole', label: 'Publisher Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'metadataPointOfContactName', label: 'Metadata Point of Contact', type: 'text' },
                    { name: 'metadataPointOfContactRole', label: 'Metadata Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea' },
                    { name: 'scope', label: 'Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] },
                    { name: 'conformity', label: 'Conformity', type: 'select',
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] }
                ]
            },
            {
                title: 'Distribution',
                fields: [
                    { name: 'distributionFormat', label: 'Distribution Format', type: 'text' },
                    { name: 'distributionUrl', label: 'Distribution URL', type: 'url' },
                    { name: 'distributionAccessConstraints', label: 'Access Constraints', type: 'textarea' },
                    { name: 'distributionUseConstraints', label: 'Use Constraints', type: 'textarea' },
                    { name: 'distributionUseLimitation', label: 'Use Limitation', type: 'textarea' },
                    { name: 'distributionFormatVersion', label: 'Format Version', type: 'text' },
                    { name: 'distributionSize', label: 'Distribution Size', type: 'text' },
                    { name: 'distributionUnits', label: 'Size Units', type: 'select',
                      options: ['bytes', 'kilobytes', 'megabytes', 'gigabytes', 'terabytes'] },
                    { name: 'distributionTransferOptions', label: 'Transfer Options', type: 'textarea' }
                ]
            },
            {
                title: 'Maintenance',
                fields: [
                    { name: 'maintenanceFrequency', label: 'Maintenance Frequency', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'maintenanceNote', label: 'Maintenance Note', type: 'textarea' },
                    { name: 'maintenanceDate', label: 'Last Maintenance Date', type: 'date' },
                    { name: 'maintenanceScope', label: 'Maintenance Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] }
                ]
            }
        ]
    },
    'ISO 19139': {
        required: ['title', 'abstract', 'purpose', 'spatial_extent', 'temporal_extent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'purpose', label: 'Purpose', type: 'textarea', required: true },
                    { name: 'status', label: 'Status', type: 'select', required: true, 
                      options: ['completed', 'historicalArchive', 'obsolete', 'onGoing', 'planned', 'required', 'underDevelopment'] },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatial_extent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'crsType', label: 'CRS Type', type: 'select', options: ['geographic', 'projected', 'vertical'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalStart', label: 'Start Date', type: 'date' },
                    { name: 'temporalEnd', label: 'End Date', type: 'date' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea', required: true },
                    { name: 'scope', label: 'Scope', type: 'select', required: true,
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] },
                    { name: 'conformity', label: 'Conformity', type: 'select',
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] },
                    { name: 'qualityReport', label: 'Quality Report', type: 'textarea' },
                    { name: 'qualityReportDate', label: 'Quality Report Date', type: 'date' }
                ]
            }
        ]
    },
    'INSPIRE': {
        required: ['title', 'abstract', 'resourceType', 'spatialExtent', 'temporalExtent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'resourceType', label: 'Resource Type', type: 'select', required: true, 
                      options: ['dataset', 'series', 'service'] },
                    { name: 'conformity', label: 'Conformity', type: 'select', required: true,
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['Addresses', 'Administrative units', 'Agricultural and aquaculture facilities', 
                              'Area management/restriction/regulation zones and reporting units', 'Atmospheric conditions', 
                              'Bio-geographical regions', 'Buildings', 'Cadastral parcels', 'Coordinate reference systems', 
                              'Elevation', 'Energy resources', 'Environmental monitoring facilities', 'Geographical grid systems', 
                              'Geographical names', 'Habitats and biotopes', 'Hydrography', 'Land cover', 'Land use', 
                              'Meteorological geographical features', 'Mineral resources', 'Natural risk zones', 
                              'Oceanographic geographical features', 'Orthoimagery', 'Population distribution — demography', 
                              'Production and industrial facilities', 'Protected sites', 'Sea regions', 'Soil', 
                              'Species distribution', 'Statistical units', 'Transport networks', 'Utility and governmental services'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialRepresentationType', label: 'Spatial Representation Type', type: 'select',
                      options: ['vector', 'grid', 'textTable', 'tin', 'stereoModel', 'video'] },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalStart', label: 'Start Date', type: 'date' },
                    { name: 'temporalEnd', label: 'End Date', type: 'date' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Responsible Parties',
                fields: [
                    { name: 'pointOfContactName', label: 'Point of Contact Name', type: 'text', required: true },
                    { name: 'pointOfContactOrg', label: 'Point of Contact Organization', type: 'text' },
                    { name: 'pointOfContactEmail', label: 'Point of Contact Email', type: 'text' },
                    { name: 'pointOfContactRole', label: 'Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'publisherName', label: 'Publisher Name', type: 'text' },
                    { name: 'publisherOrg', label: 'Publisher Organization', type: 'text' },
                    { name: 'publisherRole', label: 'Publisher Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'metadataPointOfContactName', label: 'Metadata Point of Contact', type: 'text' },
                    { name: 'metadataPointOfContactRole', label: 'Metadata Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea' },
                    { name: 'conformity', label: 'Conformity', type: 'select', required: true,
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] },
                    { name: 'qualityReport', label: 'Quality Report', type: 'textarea' },
                    { name: 'qualityReportDate', label: 'Quality Report Date', type: 'date' }
                ]
            },
            {
                title: 'Distribution',
                fields: [
                    { name: 'distributionFormat', label: 'Distribution Format', type: 'text' },
                    { name: 'distributionUrl', label: 'Distribution URL', type: 'url' },
                    { name: 'distributionAccessConstraints', label: 'Access Constraints', type: 'textarea' },
                    { name: 'distributionUseConstraints', label: 'Use Constraints', type: 'textarea' },
                    { name: 'distributionUseLimitation', label: 'Use Limitation', type: 'textarea' },
                    { name: 'distributionFormatVersion', label: 'Format Version', type: 'text' },
                    { name: 'distributionSize', label: 'Distribution Size', type: 'text' },
                    { name: 'distributionUnits', label: 'Size Units', type: 'select',
                      options: ['bytes', 'kilobytes', 'megabytes', 'gigabytes', 'terabytes'] },
                    { name: 'distributionTransferOptions', label: 'Transfer Options', type: 'textarea' }
                ]
            },
            {
                title: 'Maintenance',
                fields: [
                    { name: 'maintenanceFrequency', label: 'Maintenance Frequency', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'maintenanceNote', label: 'Maintenance Note', type: 'textarea' },
                    { name: 'maintenanceDate', label: 'Last Maintenance Date', type: 'date' },
                    { name: 'maintenanceScope', label: 'Maintenance Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] }
                ]
            }
        ]
    },
    'OGC CSW': {
        required: ['title', 'abstract', 'type', 'subject', 'format'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'type', label: 'Type', type: 'select', required: true,
                      options: ['dataset', 'series', 'service', 'software', 'other'] },
                    { name: 'subject', label: 'Subject', type: 'text', required: true },
                    { name: 'format', label: 'Format', type: 'text', required: true },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map' },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialRepresentationType', label: 'Spatial Representation Type', type: 'select',
                      options: ['vector', 'grid', 'textTable', 'tin', 'stereoModel', 'video'] },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Additional Information',
                fields: [
                    { name: 'rights', label: 'Rights', type: 'textarea' },
                    { name: 'source', label: 'Source', type: 'text' },
                    { name: 'creator', label: 'Creator', type: 'text' },
                    { name: 'contributor', label: 'Contributor', type: 'text' },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'language', label: 'Language', type: 'text' },
                    { name: 'relation', label: 'Relation', type: 'text' },
                    { name: 'coverage', label: 'Coverage', type: 'text' },
                    { name: 'identifier', label: 'Identifier', type: 'text' },
                    { name: 'modified', label: 'Modified Date', type: 'date' },
                    { name: 'created', label: 'Created Date', type: 'date' },
                    { name: 'valid', label: 'Valid Date', type: 'date' },
                    { name: 'available', label: 'Available Date', type: 'date' },
                    { name: 'issued', label: 'Issued Date', type: 'date' }
                ]
            }
        ]
    },
    'Dublin Core': {
        required: ['title', 'creator', 'subject', 'description'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'creator', label: 'Creator', type: 'text', required: true },
                    { name: 'subject', label: 'Subject', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea', required: true },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'contributor', label: 'Contributor', type: 'text' },
                    { name: 'date', label: 'Date', type: 'date' },
                    { name: 'type', label: 'Type', type: 'select',
                      options: ['Collection', 'Dataset', 'Event', 'Image', 'InteractiveResource', 'MovingImage', 'PhysicalObject', 'Service', 'Software', 'Sound', 'StillImage', 'Text'] },
                    { name: 'format', label: 'Format', type: 'text' },
                    { name: 'identifier', label: 'Identifier', type: 'text' },
                    { name: 'source', label: 'Source', type: 'text' },
                    { name: 'language', label: 'Language', type: 'text' },
                    { name: 'relation', label: 'Relation', type: 'text' },
                    { name: 'coverage', label: 'Coverage', type: 'text' },
                    { name: 'rights', label: 'Rights', type: 'textarea' },
                    { name: 'audience', label: 'Audience', type: 'text' },
                    { name: 'provenance', label: 'Provenance', type: 'textarea' },
                    { name: 'rightsHolder', label: 'Rights Holder', type: 'text' },
                    { name: 'accrualMethod', label: 'Accrual Method', type: 'select',
                      options: ['deposit', 'purchase', 'inheritance', 'generation', 'integration', 'migration'] },
                    { name: 'accrualPeriodicity', label: 'Accrual Periodicity', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'accrualPolicy', label: 'Accrual Policy', type: 'select',
                      options: ['closed', 'open', 'restricted'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map' },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' }
                ]
            }
        ]
    }
};

function populateFieldsFromDataset(dataset) {
    let metadataValues = {};
    
    // Parse XML metadata if available
    if (dataset.metadata_xml) {
        try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(dataset.metadata_xml, 'text/xml');
            
            // Helper function to get XML value
            function getXmlValue(xpath) {
                const result = xmlDoc.evaluate(xpath, xmlDoc, 
                    (prefix) => {
                        const ns = {
                            'gmd': 'http://www.isotc211.org/2005/gmd',
                            'gco': 'http://www.isotc211.org/2005/gco'
                        };
                        return ns[prefix] || null;
                    }, 
                    XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                return result.singleNodeValue?.textContent.trim() || null;
            }

            metadataValues = {
                title: getXmlValue('//gmd:title/gco:CharacterString'),
                abstract: getXmlValue('//gmd:abstract/gco:CharacterString'),
                purpose: getXmlValue('//gmd:purpose/gco:CharacterString'),
                topicCategory: getXmlValue('//gmd:topicCategory/gmd:MD_TopicCategoryCode'),
                keywords: Array.from(xmlDoc.evaluate('//gmd:keyword/gco:CharacterString', xmlDoc, 
                    (prefix) => {
                        const ns = {
                            'gmd': 'http://www.isotc211.org/2005/gmd',
                            'gco': 'http://www.isotc211.org/2005/gco'
                        };
                        return ns[prefix] || null;
                    }, 
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null)).map(node => node.textContent),
                spatialExtent: {
                    westBoundLongitude: getXmlValue('//gmd:westBoundLongitude/gco:Decimal'),
                    eastBoundLongitude: getXmlValue('//gmd:eastBoundLongitude/gco:Decimal'),
                    southBoundLatitude: getXmlValue('//gmd:southBoundLatitude/gco:Decimal'),
                    northBoundLatitude: getXmlValue('//gmd:northBoundLatitude/gco:Decimal')
                },
                crs: getXmlValue('//gmd:referenceSystemInfo//gmd:code//gco:CharacterString'),
                crsType: getXmlValue('//gmd:referenceSystemInfo//gmd:referenceSystemType//gmd:MD_ReferenceSystemTypeCode'),
                spatialResolutionDistance: getXmlValue('//gmd:spatialResolution[1]//gmd:distance//gco:Distance'),
                spatialResolutionVertical: getXmlValue('//gmd:spatialResolution[2]//gmd:vertical//gco:Distance'),
                spatialResolutionVerticalUnits: getXmlValue('//gmd:spatialResolution[2]//gmd:vertical//gco:Distance/@uom'),
                spatialRepresentationType: getXmlValue('//gmd:spatialRepresentationType//gmd:MD_SpatialRepresentationTypeCode'),
                distributionFormat: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:distributionFormat/gmd:MD_Format/gmd:name/gco:CharacterString'),
                distributionFormatVersion: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:distributionFormat/gmd:MD_Format/gmd:version/gco:CharacterString'),
                distributionUrl: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:transferOptions/gmd:MD_DigitalTransferOptions/gmd:onLine/gmd:CI_OnlineResource/gmd:linkage/gmd:URL'),
                distributionTransferOptions: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:transferOptions/gmd:MD_DigitalTransferOptions/gmd:onLine/gmd:CI_OnlineResource/gmd:description/gco:CharacterString'),
                distributionSize: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:distributionFormat/gmd:MD_Format/gmd:fileSize/gco:Real'),
                distributionUnits: getXmlValue('//gmd:distributionInfo/gmd:MD_Distribution/gmd:distributionFormat/gmd:MD_Format/gmd:fileSize/gco:Real/@uom'),
                distributionAccessConstraints: getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:accessConstraints/gmd:MD_RestrictionCode') || 
                                            getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_Constraints/gmd:accessConstraints/gco:CharacterString'),
                distributionUseConstraints: getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:useConstraints/gmd:MD_RestrictionCode') || 
                                          getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_Constraints/gmd:useConstraints/gco:CharacterString'),
                distributionUseLimitation: getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_Constraints/gmd:useLimitation/gco:CharacterString') || 
                                         getXmlValue('//gmd:identificationInfo/gmd:MD_DataIdentification/gmd:resourceConstraints/gmd:MD_LegalConstraints/gmd:useLimitation/gco:CharacterString')
            };
            // If only one of spatialResolution or spatialResolutionDistance is present, set both to the same value
            if (!metadataValues.spatialResolutionDistance && metadataValues.spatialResolution) {
                metadataValues.spatialResolution = metadataValues.spatialResolutionDistance;
            }
        } catch (error) {
            console.error('Error parsing metadata XML:', error);
        }
    }

    // Populate form fields with values from metadata or fallback to dataset properties
    Object.keys(metadataValues).forEach(key => {
        const value = metadataValues[key];
        const field = document.querySelector(`[name="${key}"]`);
        console.log('Populating', key, 'with', value, '-> field:', field);
        if (field && value !== null && value !== undefined) {
            if (field.type === 'checkbox') {
                field.checked = value === 'true' || value === true;
            } else if (field.tagName === 'SELECT') {
                const option = Array.from(field.options).find(opt => opt.value === value);
                if (option) {
                    field.value = value;
                }
            } else {
                field.value = value;
            }
        }
    });

    // Handle special cases
    if (metadataValues.keywords) {
        const keywordsField = document.querySelector('[name="keywords"]');
        if (keywordsField) {
            keywordsField.value = metadataValues.keywords.join(', ');
        }
    }

    if (metadataValues.spatialExtent) {
        const { westBoundLongitude, eastBoundLongitude, southBoundLatitude, northBoundLatitude } = metadataValues.spatialExtent;
        const extentFields = {
            'westBoundLongitude': westBoundLongitude,
            'eastBoundLongitude': eastBoundLongitude,
            'southBoundLatitude': southBoundLatitude,
            'northBoundLatitude': northBoundLatitude
        };

        Object.entries(extentFields).forEach(([fieldName, value]) => {
            const field = document.querySelector(`[name="${fieldName}"]`);
            if (field && value !== null && value !== undefined) {
                field.value = value;
            }
        });
    }

    // Fallback to dataset properties if metadata values are not available
    if (!metadataValues.title && dataset.title) {
        const titleField = document.querySelector('[name="title"]');
        if (titleField) titleField.value = dataset.title;
    }

    if (!metadataValues.abstract && dataset.description) {
        const abstractField = document.querySelector('[name="abstract"]');
        if (abstractField) abstractField.value = dataset.description;
    }

    // Set default values for spatial fields if not present
    if (!metadataValues.crs) {
        const crsField = document.querySelector('[name="crs"]');
        if (crsField) crsField.value = 'EPSG:4326';
    }

    if (!metadataValues.crsType) {
        const crsTypeField = document.querySelector('[name="crsType"]');
        if (crsTypeField) crsTypeField.value = 'geographic';
    }

    if (!metadataValues.spatialRepresentationType) {
        const spatialRepTypeField = document.querySelector('[name="spatialRepresentationType"]');
        if (spatialRepTypeField) spatialRepTypeField.value = 'vector';
    }

    if (!metadataValues.spatialResolutionVerticalUnits) {
        const spatialResVertUnitsField = document.querySelector('[name="spatialResolutionVerticalUnits"]');
        if (spatialResVertUnitsField) spatialResVertUnitsField.value = 'meters';
    }
}

// Call populateFieldsFromDataset when the page loads
document.addEventListener('DOMContentLoaded', function() {
    const dataset = {{ dataset|json_encode|raw }};
    populateFieldsFromDataset(dataset);
});

document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded');
    const standardSelect = document.getElementById('metadata_standard');
    const dynamicFieldsContainer = document.getElementById('dynamicFields');
    const dataset = {{ dataset|json_encode|raw }};
    
    console.log('Initial standard:', standardSelect.value);
    console.log('Full dataset object:', JSON.stringify(dataset, null, 2));
    console.log('Dataset spatial_extent type:', typeof dataset.spatial_extent);
    console.log('Dataset spatial_extent:', dataset.spatial_extent);
    if (dataset.spatial_extent) {
        console.log('Spatial extent coordinates:', dataset.spatial_extent.coordinates);
        if (dataset.spatial_extent.coordinates && dataset.spatial_extent.coordinates[0]) {
            console.log('First coordinate array:', dataset.spatial_extent.coordinates[0]);
        }
    }
    console.log('Dataset metadata:', dataset.metadata);

    // Function to populate field values
    function populateFieldValues(field, value) {
        console.log('Populating field:', field.name, 'with value:', value);
        const input = document.getElementById(field.name);
        if (!input) {
            console.log('Input not found for field:', field.name);
            return;
        }

        if (field.type === 'map') {
            // Handle map fields separately
            console.log('Dataset spatial extent:', dataset.spatial_extent);
            console.log('Dataset metadata:', dataset.metadata);
            
            // Try to get spatial extent from different possible locations
            let spatialExtent = null;
            if (dataset.spatial_extent) {
                // Get the CRS from metadata or default to EPSG:26713
                const crs = dataset.metadata?.crs || 'urn:ogc:def:crs:EPSG::26713';
                console.log('Using CRS:', crs);
                
                // Extract coordinates from the spatial extent
                const west = parseFloat(dataset.spatial_extent.westBoundLongitude);
                const east = parseFloat(dataset.spatial_extent.eastBoundLongitude);
                const south = parseFloat(dataset.spatial_extent.southBoundLatitude);
                const north = parseFloat(dataset.spatial_extent.northBoundLatitude);
                
                console.log('Raw coordinates:', { west, east, south, north });
                
                if (!isNaN(west) && !isNaN(east) && !isNaN(south) && !isNaN(north)) {
                    try {
                        // Convert coordinates from EPSG:26713 to EPSG:4326
                        const proj26713 = 'EPSG:26713';
                        const proj4326 = 'EPSG:4326';
                        
                        // Ensure the projections are registered
                        if (!ol.proj.get(proj26713)) {
                            console.error('EPSG:26713 projection not registered');
                            return;
                        }
                        
                        // Convert each corner point
                        const sw = ol.proj.transform([west, south], proj26713, proj4326);
                        const nw = ol.proj.transform([west, north], proj26713, proj4326);
                        const ne = ol.proj.transform([east, north], proj26713, proj4326);
                        const se = ol.proj.transform([east, south], proj26713, proj4326);
                        
                        console.log('Converted coordinates:', { sw, nw, ne, se });
                        
                        // Set the individual coordinate fields
                        const westInput = fieldElements.get('westBound');
                        const eastInput = fieldElements.get('eastBound');
                        const southInput = fieldElements.get('southBound');
                        const northInput = fieldElements.get('northBound');
                        
                        if (westInput) westInput.value = sw[0].toFixed(6);
                        if (eastInput) eastInput.value = ne[0].toFixed(6);
                        if (southInput) southInput.value = sw[1].toFixed(6);
                        if (northInput) northInput.value = nw[1].toFixed(6);
                        
                        // Create the GeoJSON structure
                        const geoJson = {
                            type: 'Polygon',
                            coordinates: [[
                                [sw[0], sw[1]],
                                [nw[0], nw[1]],
                                [ne[0], ne[1]],
                                [se[0], se[1]],
                                [sw[0], sw[1]]
                            ]]
                        };
                        
                        // Create or update hidden input for the full GeoJSON
                        let hiddenInput = document.getElementById('spatial_extent_geojson');
                        if (!hiddenInput) {
                            hiddenInput = document.createElement('input');
                            hiddenInput.type = 'hidden';
                            hiddenInput.id = 'spatial_extent_geojson';
                            hiddenInput.name = 'spatial_extent';
                            document.querySelector('form').appendChild(hiddenInput);
                        }
                        hiddenInput.value = JSON.stringify(geoJson);
                        
                        // Store original coordinates
                        let originalCoordsInput = document.getElementById('spatial_extent_original');
                        if (!originalCoordsInput) {
                            originalCoordsInput = document.createElement('input');
                            originalCoordsInput.type = 'hidden';
                            originalCoordsInput.id = 'spatial_extent_original';
                            originalCoordsInput.name = 'spatial_extent_original';
                            document.querySelector('form').appendChild(originalCoordsInput);
                        }
                        originalCoordsInput.value = JSON.stringify({
                            westBoundLongitude: west,
                            eastBoundLongitude: east,
                            southBoundLatitude: south,
                            northBoundLatitude: north,
                            crs: crs
                        });
                        
                        // Trigger map update after a short delay to ensure map is initialized
                        setTimeout(() => {
                            if (typeof updateExtentBox === 'function') {
                                updateExtentBox();
                            }
                        }, 200);
                    } catch (error) {
                        console.error('Error converting coordinates:', error);
                        // Fallback to using the raw coordinates without conversion
                        const westInput = fieldElements.get('westBound');
                        const eastInput = fieldElements.get('eastBound');
                        const southInput = fieldElements.get('southBound');
                        const northInput = fieldElements.get('northBound');
                        
                        if (westInput) westInput.value = west;
                        if (eastInput) eastInput.value = east;
                        if (southInput) southInput.value = south;
                        if (northInput) northInput.value = north;
                        
                        console.log('Using raw coordinates as fallback');
                    }
                } else {
                    console.log('Invalid coordinate values after parsing');
                }
            }
        } else if (field.type === 'select') {
            // For select fields, find and select the matching option
            const option = Array.from(input.options).find(opt => opt.value === value);
            if (option) {
                option.selected = true;
            }
        } else {
            // For other field types, set the value directly
            input.value = value || '';
        }
    }

    // Function to load fields for a standard
    function loadFieldsForStandard(standard) {
        console.log('Loading fields for standard:', standard);
        console.log('Full dataset:', dataset);
        const standardConfig = standardFields[standard];
        if (!standardConfig) {
            console.error('No configuration found for standard:', standard);
            return;
        }

        console.log('Found standard config:', standardConfig);
        dynamicFieldsContainer.innerHTML = '';
        
        // Create a map to store field elements for later population
        const fieldElements = new Map();
        
        standardConfig.sections.forEach(section => {
            console.log('Creating section:', section.title);
            const sectionDiv = document.createElement('div');
            sectionDiv.className = 'metadata-section';
            
            const sectionTitle = document.createElement('h2');
            sectionTitle.className = 'text-xl font-semibold mb-4';
            sectionTitle.textContent = section.title;
            sectionDiv.appendChild(sectionTitle);

            const table = document.createElement('table');
            table.className = 'metadata-table';
            const tbody = document.createElement('tbody');
            
            section.fields.forEach(field => {
                console.log('Creating field:', field.name);
                const row = document.createElement('tr');
                
                const labelCell = document.createElement('th');
                const label = document.createElement('label');
                label.className = 'form-label';
                if (field.required) {
                    label.classList.add('required-field');
                }
                label.textContent = field.label;
                label.setAttribute('for', field.name);
                labelCell.appendChild(label);
                row.appendChild(labelCell);

                const inputCell = document.createElement('td');
                let input;
                
                if (field.type === 'map') {
                    // Create map container
                    const mapDiv = document.createElement('div');
                    mapDiv.id = 'map';
                    mapDiv.style.height = '400px';
                    mapDiv.style.marginBottom = '1rem';
                    inputCell.appendChild(mapDiv);
                    
                    // Create coordinate input fields
                    const coordContainer = document.createElement('div');
                    coordContainer.className = 'grid grid-cols-2 gap-4 mt-2';
                    
                    // Create coordinate input groups
                    const bounds = [
                        { id: 'westBound', label: 'West Bound Longitude', name: 'westBoundLongitude' },
                        { id: 'eastBound', label: 'East Bound Longitude', name: 'eastBoundLongitude' },
                        { id: 'southBound', label: 'South Bound Latitude', name: 'southBoundLatitude' },
                        { id: 'northBound', label: 'North Bound Latitude', name: 'northBoundLatitude' }
                    ];
                    
                    bounds.forEach(bound => {
                        const inputGroup = document.createElement('div');
                        inputGroup.className = 'form-group';
                        
                        const label = document.createElement('label');
                        label.className = 'form-label';
                        label.textContent = bound.label;
                        label.setAttribute('for', bound.id);
                        inputGroup.appendChild(label);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = bound.id;
                        input.name = bound.name;
                        input.step = 'any';
                        input.className = 'form-input';
                        input.required = field.required;
                        input.placeholder = bound.label;
                        inputGroup.appendChild(input);
                        
                        // Store the input element for later population
                        fieldElements.set(bound.id, input);
                        
                        coordContainer.appendChild(inputGroup);
                    });
                    
                    inputCell.appendChild(coordContainer);
                    
                    // Add help text
                    const helpText = document.createElement('p');
                    helpText.className = 'text-sm text-gray-600 mt-2';
                    helpText.textContent = 'Enter coordinates in decimal degrees (e.g., -180 to 180 for longitude, -90 to 90 for latitude)';
                    inputCell.appendChild(helpText);

                    // Initialize map after a short delay to ensure DOM is ready
                    setTimeout(() => {
                        const map = new ol.Map({
                            target: 'map',
                            layers: [
                                new ol.layer.Tile({
                                    source: new ol.source.OSM()
                                })
                            ],
                            view: new ol.View({
                                center: ol.proj.fromLonLat([0, 0]),
                                zoom: 2
                            })
                        });

                        // Add extent box
                        let extentBox = null;
                        const extentSource = new ol.source.Vector();
                        const extentLayer = new ol.layer.Vector({
                            source: extentSource,
                            style: new ol.style.Style({
                                stroke: new ol.style.Stroke({
                                    color: 'rgba(0, 0, 255, 1.0)',
                                    width: 2
                                }),
                                fill: new ol.style.Fill({
                                    color: 'rgba(0, 0, 255, 0.1)'
                                })
                            })
                        });
                        map.addLayer(extentLayer);

                        // Make updateExtentBox available globally
                        window.updateExtentBox = function() {
                            const west = parseFloat(document.getElementById('westBound').value);
                            const east = parseFloat(document.getElementById('eastBound').value);
                            const south = parseFloat(document.getElementById('southBound').value);
                            const north = parseFloat(document.getElementById('northBound').value);

                            console.log('Updating extent box with values:', { west, east, south, north });

                            if (isNaN(west) || isNaN(east) || isNaN(south) || isNaN(north)) {
                                console.log('Invalid coordinate values');
                                return;
                            }

                            const extent = ol.proj.transformExtent(
                                [west, south, east, north],
                                'EPSG:4326',
                                'EPSG:3857'
                            );

                            if (extentBox) {
                                extentSource.removeFeature(extentBox);
                            }

                            extentBox = new ol.Feature({
                                geometry: new ol.geom.Polygon.fromExtent(extent)
                            });
                            extentSource.addFeature(extentBox);
                            map.getView().fit(extent, { padding: [50, 50, 50, 50] });

                            // Update the GeoJSON hidden input
                            const geoJson = {
                                type: 'Polygon',
                                coordinates: [[
                                    [west, south],
                                    [west, north],
                                    [east, north],
                                    [east, south],
                                    [west, south]
                                ]]
                            };
                            
                            let hiddenInput = document.getElementById('spatial_extent_geojson');
                            if (!hiddenInput) {
                                hiddenInput = document.createElement('input');
                                hiddenInput.type = 'hidden';
                                hiddenInput.id = 'spatial_extent_geojson';
                                hiddenInput.name = 'spatial_extent';
                                document.querySelector('form').appendChild(hiddenInput);
                            }
                            hiddenInput.value = JSON.stringify(geoJson);
                            
                            console.log('Updated spatial extent GeoJSON:', geoJson);
                        };

                        // Add event listeners to extent inputs
                        ['westBound', 'eastBound', 'southBound', 'northBound'].forEach(id => {
                            document.getElementById(id).addEventListener('change', updateExtentBox);
                        });

                        // Initial extent box update will be triggered after population
                    }, 100);
                } else {
                    switch (field.type) {
                        case 'textarea':
                            input = document.createElement('textarea');
                            input.className = 'form-textarea';
                            break;
                        case 'select':
                            input = document.createElement('select');
                            input.className = 'form-select';
                            field.options.forEach(option => {
                                const opt = document.createElement('option');
                                opt.value = option;
                                opt.textContent = option;
                                input.appendChild(opt);
                            });
                            break;
                        default:
                            input = document.createElement('input');
                            input.type = field.type;
                            input.className = 'form-input';
                    }
                    
                    input.id = field.name;
                    input.name = field.name;
                    if (field.required) {
                        input.required = true;
                    }
                    inputCell.appendChild(input);
                    
                    // Store the input element for later population
                    fieldElements.set(field.name, input);
                }
                
                row.appendChild(inputCell);
                tbody.appendChild(row);
            });
            
            table.appendChild(tbody);
            sectionDiv.appendChild(table);
            dynamicFieldsContainer.appendChild(sectionDiv);
        });
        
        // Now that all fields are created, populate them
        standardConfig.sections.forEach(section => {
            section.fields.forEach(field => {
                let value;
                if (field.name === 'title') {
                    value = dataset.title;
                } else if (field.name === 'description') {
                    value = dataset.description;
                } else if (field.name === 'keywords') {
                    // If dataset.keywords is an array, join it for the textarea
                    if (Array.isArray(dataset.keywords)) {
                        value = dataset.keywords.join(', ');
                    } else if (dataset.metadata && Array.isArray(dataset.metadata.keywords)) {
                        value = dataset.metadata.keywords.join(', ');
                    } else if (dataset.metadata && typeof dataset.metadata.keywords === 'string') {
                        value = dataset.metadata.keywords;
                    } else if (dataset.keywords) {
                        value = dataset.keywords;
                    } else {
                        value = '';
                    }
                } else if (field.type === 'map') {
                    // For map fields, handle the population separately
                    if (dataset.spatial_extent) {
                        const crs = dataset.metadata?.crs || 'urn:ogc:def:crs:EPSG::26713';
                        console.log('Using CRS:', crs);
                        
                        const west = parseFloat(dataset.spatial_extent.westBoundLongitude);
                        const east = parseFloat(dataset.spatial_extent.eastBoundLongitude);
                        const south = parseFloat(dataset.spatial_extent.southBoundLatitude);
                        const north = parseFloat(dataset.spatial_extent.northBoundLatitude);
                        
                        console.log('Raw coordinates:', { west, east, south, north });
                        
                        if (!isNaN(west) && !isNaN(east) && !isNaN(south) && !isNaN(north)) {
                            try {
                                // Convert coordinates from EPSG:26713 to EPSG:4326
                                const proj26713 = 'EPSG:26713';
                                const proj4326 = 'EPSG:4326';
                                
                                // Ensure the projections are registered
                                if (!ol.proj.get(proj26713)) {
                                    console.error('EPSG:26713 projection not registered');
                                    return;
                                }
                                
                                // Convert each corner point
                                const sw = ol.proj.transform([west, south], proj26713, proj4326);
                                const nw = ol.proj.transform([west, north], proj26713, proj4326);
                                const ne = ol.proj.transform([east, north], proj26713, proj4326);
                                const se = ol.proj.transform([east, south], proj26713, proj4326);
                                
                                console.log('Converted coordinates:', { sw, nw, ne, se });
                                
                                // Set the individual coordinate fields
                                const westInput = fieldElements.get('westBound');
                                const eastInput = fieldElements.get('eastBound');
                                const southInput = fieldElements.get('southBound');
                                const northInput = fieldElements.get('northBound');
                                
                                if (westInput) westInput.value = sw[0].toFixed(6);
                                if (eastInput) eastInput.value = ne[0].toFixed(6);
                                if (southInput) southInput.value = sw[1].toFixed(6);
                                if (northInput) northInput.value = nw[1].toFixed(6);
                                
                                // Create the GeoJSON structure
                                const geoJson = {
                                    type: 'Polygon',
                                    coordinates: [[
                                        [sw[0], sw[1]],
                                        [nw[0], nw[1]],
                                        [ne[0], ne[1]],
                                        [se[0], se[1]],
                                        [sw[0], sw[1]]
                                    ]]
                                };
                                
                                // Create or update hidden input for the full GeoJSON
                                let hiddenInput = document.getElementById('spatial_extent_geojson');
                                if (!hiddenInput) {
                                    hiddenInput = document.createElement('input');
                                    hiddenInput.type = 'hidden';
                                    hiddenInput.id = 'spatial_extent_geojson';
                                    hiddenInput.name = 'spatial_extent';
                                    document.querySelector('form').appendChild(hiddenInput);
                                }
                                hiddenInput.value = JSON.stringify(geoJson);
                                
                                // Store original coordinates
                                let originalCoordsInput = document.getElementById('spatial_extent_original');
                                if (!originalCoordsInput) {
                                    originalCoordsInput = document.createElement('input');
                                    originalCoordsInput.type = 'hidden';
                                    originalCoordsInput.id = 'spatial_extent_original';
                                    originalCoordsInput.name = 'spatial_extent_original';
                                    document.querySelector('form').appendChild(originalCoordsInput);
                                }
                                originalCoordsInput.value = JSON.stringify({
                                    westBoundLongitude: west,
                                    eastBoundLongitude: east,
                                    southBoundLatitude: south,
                                    northBoundLatitude: north,
                                    crs: crs
                                });
                                
                                // Trigger map update after a short delay to ensure map is initialized
                                setTimeout(() => {
                                    if (typeof updateExtentBox === 'function') {
                                        updateExtentBox();
                                    }
                                }, 200);
                            } catch (error) {
                                console.error('Error converting coordinates:', error);
                                // Fallback to using the raw coordinates without conversion
                                const westInput = fieldElements.get('westBound');
                                const eastInput = fieldElements.get('eastBound');
                                const southInput = fieldElements.get('southBound');
                                const northInput = fieldElements.get('northBound');
                                
                                if (westInput) westInput.value = west;
                                if (eastInput) eastInput.value = east;
                                if (southInput) southInput.value = south;
                                if (northInput) northInput.value = north;
                                
                                console.log('Using raw coordinates as fallback');
                            }
                        }
                    }
                } else if (field.name === 'temporalStart' || field.name === 'temporalEnd') {
                    // Handle temporal dates from metadata XML
                    if (dataset.metadata_xml) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(dataset.metadata_xml, 'text/xml');
                        const temporalNode = xmlDoc.querySelector('temporal');
                        if (temporalNode) {
                            if (field.name === 'temporalStart') {
                                value = temporalNode.querySelector('startDate')?.textContent || '';
                            } else {
                                value = temporalNode.querySelector('endDate')?.textContent || '';
                            }
                        }
                    }
                    // Fallback to metadata object
                    if (!value && dataset.metadata) {
                        value = dataset.metadata[field.name] || '';
                    }
                } else if (field.name === 'pointOfContactName' || field.name === 'pointOfContactOrg' || field.name === 'pointOfContactEmail') {
                    // Try to get from metadata object
                    if (dataset.metadata) {
                        value = dataset.metadata[field.name] || '';
                    }
                    // Fallback to metadata XML
                    if ((!value || value === '0') && dataset.metadata_xml) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(dataset.metadata_xml, 'text/xml');
                        const pocNode = xmlDoc.querySelector('pointOfContact');
                        if (pocNode) {
                            if (field.name === 'pointOfContactName') value = pocNode.querySelector('name')?.textContent || '';
                            if (field.name === 'pointOfContactOrg') value = pocNode.querySelector('organization')?.textContent || '';
                            if (field.name === 'pointOfContactEmail') value = pocNode.querySelector('email')?.textContent || '';
                        }
                    }
                } else if (field.name === 'publisherName' || field.name === 'publisherOrg') {
                    if (dataset.metadata) {
                        value = dataset.metadata[field.name] || '';
                    }
                    if ((!value || value === '0') && dataset.metadata_xml) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(dataset.metadata_xml, 'text/xml');
                        const pubNode = xmlDoc.querySelector('publisher');
                        if (pubNode) {
                            if (field.name === 'publisherName') value = pubNode.querySelector('name')?.textContent || '';
                            if (field.name === 'publisherOrg') value = pubNode.querySelector('organization')?.textContent || '';
                        }
                    }
                } else {
                    // For other fields, try metadata object first
                    value = dataset.metadata ? dataset.metadata[field.name] : null;
                    
                    // If not found in metadata object, try metadata XML
                    if (!value && dataset.metadata_xml) {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(dataset.metadata_xml, 'text/xml');
                        
                        // Try to find the field in the XML
                        const fieldNode = xmlDoc.querySelector(field.name);
                        if (fieldNode) {
                            value = fieldNode.textContent;
                        } else {
                            // Try some common variations of the field name
                            const variations = [
                                field.name,
                                field.name.replace(/([A-Z])/g, '-$1').toLowerCase(), // camelCase to hyphen-case
                                field.name.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase() // camelCase to snake_case
                            ];
                            
                            for (const variation of variations) {
                                const node = xmlDoc.querySelector(variation);
                                if (node) {
                                    value = node.textContent;
                                    break;
                                }
                            }
                        }
                    }
                }
                
                if (value !== undefined && value !== null && field.type !== 'map') {
                    const input = fieldElements.get(field.name);
                    if (input) {
                        if (field.type === 'select') {
                            const option = Array.from(input.options).find(opt => opt.value === value);
                            if (option) {
                                option.selected = true;
                            }
                        } else {
                            input.value = value;
                        }
                        console.log(`Set ${field.name} to:`, value);
                    } else {
                        console.log(`Input not found for field: ${field.name}`);
                    }
                }
            });
        });
    }

    // Load fields for the initially selected standard
    if (standardSelect.value) {
        console.log('Loading initial fields for standard:', standardSelect.value);
        loadFieldsForStandard(standardSelect.value);
        // After fields are created, populate them from metadata
        populateFieldsFromDataset(dataset);
    }

    // Update fields when standard changes
    standardSelect.addEventListener('change', function() {
        console.log('Standard changed to:', this.value);
        loadFieldsForStandard(this.value);
    });

    // Add this at the beginning of the script section
    const form = document.querySelector('form');
    form.addEventListener('submit', async function(e) {
        e.preventDefault(); // Prevent default submission
        console.log('Form submission intercepted');
        
        // Log form data
        const formData = new FormData(form);
        console.log('Form data:');
        for (let [key, value] of formData.entries()) {
            if (value instanceof File) {
                console.log(key + ': [File] ' + value.name);
            } else {
                console.log(key + ': ' + value);
            }
        }
        
        try {
            const response = await fetch(form.action, {
                method: 'POST',
                body: formData
            });

            console.log('Response status:', response.status);
            
            // Check if we got a redirect
            if (response.redirected) {
                window.location.href = response.url;
                return;
            }

            const text = await response.text();
            console.log('Response text:', text);

            // If the response contains a success message, redirect
            if (text.includes('success')) {
                window.location.href = '/catalog/' + {{ dataset.id }};
            } else {
                console.error('Error in form submission');
                alert('An error occurred while saving the dataset. Please try again.');
            }
        } catch (error) {
            console.error('Error submitting form:', error);
            alert('An error occurred while saving the dataset. Please try again.');
        }
    });
});

async function handleFormSubmit(event) {
    event.preventDefault();
    console.log('Form submission started');

    const form = event.target;
    const formData = new FormData(form);
    
    // Debug log all form data
    console.log('All form data:');
    for (let [key, value] of formData.entries()) {
        console.log(`${key}: ${value}`);
    }
    
    // Get spatial extent values
    const west = document.getElementById('westBound').value;
    const east = document.getElementById('eastBound').value;
    const south = document.getElementById('southBound').value;
    const north = document.getElementById('northBound').value;

    console.log('Spatial extent values before submission:', { west, east, south, north });

    // Remove any existing spatial extent data
    for (let key of formData.keys()) {
        if (key.startsWith('metadata[spatial_extent]')) {
            console.log('Removing existing spatial extent data:', key);
            formData.delete(key);
        }
    }

    // Add spatial extent data in the format expected by the model
    if (west && east && south && north) {
        // Create the spatial extent structure expected by the model
        const spatialExtent = {
            type: 'Polygon',
            coordinates: [[
                [parseFloat(west), parseFloat(south)],
                [parseFloat(west), parseFloat(north)],
                [parseFloat(east), parseFloat(north)],
                [parseFloat(east), parseFloat(south)],
                [parseFloat(west), parseFloat(south)]
            ]]
        };

        // Add the spatial extent as a single JSON string
        formData.append('spatial_extent', JSON.stringify(spatialExtent));
        console.log('Added spatial extent:', spatialExtent);
    } else {
        console.warn('Missing spatial extent values:', { west, east, south, north });
    }

    // Add all spatial metadata fields
    const spatialFields = {
        'crs': document.getElementById('crs')?.value || 'EPSG:4326',
        'crsType': document.getElementById('crsType')?.value || 'geographic',
        'spatialResolutionDistance': document.getElementById('spatialResolutionDistance')?.value || '',
        'spatialResolutionVertical': document.getElementById('spatialResolutionVertical')?.value || '',
        'spatialResolutionVerticalUnits': document.getElementById('spatialResolutionVerticalUnits')?.value || 'meters'
    };

    // Add each spatial field to the form data
    Object.entries(spatialFields).forEach(([key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
            formData.append(`metadata[${key}]`, value);
            console.log(`Added spatial field ${key}:`, value);
        }
    });

    // Add temporal information
    const temporalStart = document.getElementById('temporalExtent').value;
    const temporalEnd = document.getElementById('temporalExtentEnd')?.value;
    if (temporalStart) {
        formData.append('temporalStart', temporalStart);
        if (temporalEnd) {
            formData.append('temporalEnd', temporalEnd);
        }
    }

    // Add responsible parties
    const publisher = document.getElementById('publisher').value;
    const pointOfContact = document.getElementById('pointOfContact').value;
    if (publisher) {
        formData.append('publisher', publisher);
    }
    if (pointOfContact) {
        formData.append('pointOfContact', pointOfContact);
    }

    // Add all metadata fields with proper structure
    const metadataFields = {
        'title': document.getElementById('title')?.value || '',
        'abstract': document.getElementById('abstract')?.value || '',
        'keywords': document.getElementById('keywords')?.value?.split(',').map(k => k.trim()) || [],
        'language': document.getElementById('language')?.value || 'eng',
        'characterSet': document.getElementById('characterSet')?.value || 'utf8',
        'topicCategory': document.getElementById('topicCategory')?.value || '',
        'purpose': document.getElementById('purpose')?.value || '',
        'status': document.getElementById('status')?.value || 'completed',
        'updateFrequency': document.getElementById('updateFrequency')?.value || '',
        'accessConstraints': document.getElementById('accessConstraints')?.value || '',
        'useConstraints': document.getElementById('useConstraints')?.value || '',
        'lineage': document.getElementById('lineage')?.value || '',
        'scope': document.getElementById('scope')?.value || '',
        'spatialRepresentationType': document.getElementById('spatialRepresentationType')?.value || 'vector',
        'spatialResolutionDistance': document.getElementById('spatialResolutionDistance')?.value || '',
        'spatialResolutionVertical': document.getElementById('spatialResolutionVertical')?.value || '',
        'spatialResolutionVerticalUnits': document.getElementById('spatialResolutionVerticalUnits')?.value || 'meters',
        'crs': document.getElementById('crs')?.value || 'EPSG:4326',
        'crsType': document.getElementById('crsType')?.value || 'geographic'
    };

    // Add each metadata field to the form data
    Object.entries(metadataFields).forEach(([key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
            formData.append(`metadata[${key}]`, Array.isArray(value) ? JSON.stringify(value) : value);
            console.log(`Added metadata field ${key}:`, value);
        }
    });

    try {
        const response = await fetch(form.action, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log('Form submission response:', result);

        if (result.success) {
            window.location.href = result.redirect || '/catalog';
        } else {
            alert(result.message || 'An error occurred while saving the dataset.');
        }
    } catch (error) {
        console.error('Error submitting form:', error);
        alert('An error occurred while saving the dataset. Please try again.');
    }
}
</script>
{% endblock %} 