{% extends "layout.twig" %}

{% block title %}Add GIS Data - GIS Catalog{% endblock %}

{% block stylesheets %}
{{ parent() }}

    <!-- OpenLayers CSS -->
    <link rel="stylesheet" href="https://unpkg.com/ol@7.4.0/ol.css">
    <style>
        #map {
            width: 100%;
            height: 400px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }
        .form-group {
            margin-bottom: 1rem;
            width: 100%;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            width: 100%;
        }
        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
        }
        .form-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            min-height: 100px;
            box-sizing: border-box;
        }
        .form-select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
            background-color: white;
        }
        .form-checkbox {
            margin-right: 0.5rem;
        }
        .error-message {
            color: #dc2626;
            font-size: 0.875rem;
            margin-top: 0.25rem;
        }
        .metadata-section {
            background-color: #f9fafb;
            padding: 1.5rem;
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .required-field::after {
            content: " *";
            color: #dc2626;
        }
        /* Add table striping */
        .metadata-section:nth-child(odd) {
            background-color: #f3f4f6;
        }
        .metadata-section:nth-child(even) {
            background-color: #ffffff;
        }
        /* Make form elements consistent width */
        input[type="text"],
        input[type="url"],
        input[type="date"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ccc;
            border-radius: 0.25rem;
            box-sizing: border-box;
            font-size: 1rem;
            line-height: 1.5;
        }
        /* Add hover effect */
        .form-input:hover,
        .form-textarea:hover,
        .form-select:hover {
            border-color: #4b5563;
        }
        /* Add focus effect */
        .form-input:focus,
        .form-textarea:focus,
        .form-select:focus {
            outline: none;
            border-color: #2563eb;
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }
        /* Style section headers */
        .metadata-section h2 {
            color: #1f2937;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }
        /* Table styling for metadata fields */
        .metadata-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 1.5rem;
        }
        .metadata-table th, .metadata-table td {
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: top;
        }
        .metadata-table tr:nth-child(odd) {
            background-color: #f3f4f6;
        }
        .metadata-table tr:nth-child(even) {
            background-color: #ffffff;
        }
        .metadata-table th {
            text-align: left;
            width: 25%;
            font-weight: 500;
        }
        .metadata-table td {
            width: 75%;
        }
    </style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-8">
    <div class="mb-8">
        <a href="/catalog" class="text-blue-600 hover:text-blue-900">&larr; Back to Catalog</a>
    </div>

    <div class="bg-white rounded-lg shadow-md p-6">
        <h1 class="text-3xl font-bold mb-6">Add GIS Data</h1>

        <form action="/catalog/add" method="POST" enctype="multipart/form-data" class="space-y-6" id="datasetForm" onsubmit="return handleFormSubmit(event)">
            <!-- Metadata Standard Selection -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">Metadata Standard</h2>
                
                <div class="form-group">
                    <label for="metadata_standard" class="form-label required-field">Metadata Standard</label>
                    <select id="metadata_standard" name="metadata_standard" class="form-select" required onchange="loadTemplate(this.value)">
                        <option value="">Select a standard...</option>
                        <option value="ISO 19115">ISO 19115</option>
                        <option value="ISO 19139">ISO 19139</option>
                        <option value="INSPIRE">INSPIRE</option>
                        <option value="FGDC">FGDC</option>
                        <option value="OGC CSW">OGC CSW</option>
                        <option value="Dublin Core">Dublin Core</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="metadata_version" class="form-label required-field">Metadata Version</label>
                    <input type="text" id="metadata_version" name="metadata_version" 
                        class="form-input" value="2018" required>
                </div>
            </div>

            <!-- GIS Data URL -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">Import from URL</h2>
                <div class="form-group">
                    <label for="gis_data_url" class="form-label">GIS Data URL</label>
                    <div class="flex gap-2">
                        <input type="url" id="gis_data_url" name="gis_data_url" 
                            class="form-input flex-grow" 
                            placeholder="Enter URL to GIS data (GeoJSON, WMS, WFS, etc.)">
                        <button type="button" id="fetchMetadataBtn" 
                            class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                            Fetch Metadata
                        </button>
                    </div>
                    <div id="urlStatus" class="mt-2 text-sm"></div>
                </div>
            </div>

            <!-- WMS Details -->
            <div class="metadata-section" id="wmsDetailsSection">
                <h2 class="text-xl font-semibold mb-4">WMS Service Details</h2>
                <div class="form-group">
                    <div class="flex items-center mb-4">
                        <input type="checkbox" id="use_wms" name="use_wms" class="form-checkbox" onchange="toggleWmsDetails(this)">
                        <label for="use_wms" class="ml-2">Use WMS Service</label>
                    </div>
                </div>
                <div id="wmsFields" style="display: none;">
                    <div class="form-group">
                        <label for="wms_url" class="form-label">WMS Service URL</label>
                        <input type="url" id="wms_url" name="wms_url" 
                            class="form-input" 
                            placeholder="Enter WMS service URL (e.g., https://example.com/geoserver/wms)">
                        <div class="text-sm text-gray-500 mt-1">The URL should point to your WMS service endpoint</div>
                    </div>
                    <div class="form-group">
                        <label for="wms_layer" class="form-label">WMS Layer Name</label>
                        <input type="text" id="wms_layer" name="wms_layer" 
                            class="form-input" 
                            placeholder="Enter the exact layer name from your WMS service">
                        <div class="text-sm text-gray-500 mt-1">The exact layer name as it appears in your WMS service</div>
                    </div>
                </div>
            </div>

            <!-- Dynamic Fields Container -->
            <div id="dynamicFields">
                <!-- Fields will be loaded here based on selected template -->
            </div>

            <!-- File Upload -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">File Information</h2>
                
                <div class="form-group">
                    <label for="file" class="form-label">GIS File (Optional)</label>
                    <input type="file" id="file" name="file" accept=".shp,.geojson,.kml,.gml"
                        class="form-input">
                    {% if errors.file %}
                        <div class="error-message">{{ errors.file }}</div>
                    {% endif %}
                </div>
            </div>

            <!-- Additional Settings -->
            <div class="metadata-section">
                <h2 class="text-xl font-semibold mb-4">Additional Settings</h2>
                
                <div class="form-group">
                    <label class="form-label">Visibility</label>
                    <div class="flex items-center">
                        <input type="checkbox" id="is_public" name="is_public" value="1"
                            class="form-checkbox">
                        <label for="is_public">Make this dataset public</label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="status" class="form-label">Status</label>
                    <select id="status" name="status" class="form-select">
                        <option value="draft">Draft</option>
                        <option value="published">Published</option>
                        <option value="archived">Archived</option>
                    </select>
                </div>
            </div>

            <div class="flex justify-end space-x-4">
                <a href="/catalog" class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50">
                    Cancel
                </a>
                <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                    Add Dataset
                </button>
            </div>
        </form>
    </div>
</div>

<script src="https://unpkg.com/ol@7.4.0/dist/ol.js"></script>
<script>
// Field definitions for each standard
const standardFields = {
    'ISO 19115': {
        required: ['title', 'abstract', 'purpose', 'spatial_extent', 'temporal_extent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'purpose', label: 'Purpose', type: 'textarea', required: true },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatial_extent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'crsType', label: 'CRS Type', type: 'select', options: ['geographic', 'projected', 'vertical'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text', required: true },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Responsible Parties',
                fields: [
                    { name: 'pointOfContact', label: 'Point of Contact', type: 'text', required: true },
                    { name: 'pointOfContactRole', label: 'Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'publisherRole', label: 'Publisher Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'metadataPointOfContact', label: 'Metadata Point of Contact', type: 'text' },
                    { name: 'metadataPointOfContactRole', label: 'Metadata Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea' },
                    { name: 'scope', label: 'Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] },
                    { name: 'conformity', label: 'Conformity', type: 'select',
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] }
                ]
            },
            {
                title: 'Distribution',
                fields: [
                    { name: 'distributionFormat', label: 'Distribution Format', type: 'text' },
                    { name: 'distributionUrl', label: 'Distribution URL', type: 'url' },
                    { name: 'distributionAccessConstraints', label: 'Access Constraints', type: 'textarea' },
                    { name: 'distributionUseConstraints', label: 'Use Constraints', type: 'textarea' },
                    { name: 'distributionFormatVersion', label: 'Format Version', type: 'text' },
                    { name: 'distributionSize', label: 'Distribution Size', type: 'text' },
                    { name: 'distributionUnits', label: 'Size Units', type: 'select',
                      options: ['bytes', 'kilobytes', 'megabytes', 'gigabytes', 'terabytes'] },
                    { name: 'distributionTransferOptions', label: 'Transfer Options', type: 'textarea' }
                ]
            },
            {
                title: 'Maintenance',
                fields: [
                    { name: 'maintenanceFrequency', label: 'Maintenance Frequency', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'maintenanceNote', label: 'Maintenance Note', type: 'textarea' },
                    { name: 'maintenanceDate', label: 'Last Maintenance Date', type: 'date' },
                    { name: 'maintenanceScope', label: 'Maintenance Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] }
                ]
            }
        ]
    },
    'ISO 19139': {
        required: ['title', 'abstract', 'purpose', 'spatial_extent', 'temporal_extent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea' },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'purpose', label: 'Purpose', type: 'textarea', required: true },
                    { name: 'status', label: 'Status', type: 'select', required: true, 
                      options: ['completed', 'historicalArchive', 'obsolete', 'onGoing', 'planned', 'required', 'underDevelopment'] },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatial_extent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'crsType', label: 'CRS Type', type: 'select', options: ['geographic', 'projected', 'vertical'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text', required: true },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea', required: true },
                    { name: 'scope', label: 'Scope', type: 'select', required: true,
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] },
                    { name: 'conformity', label: 'Conformity', type: 'select',
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] },
                    { name: 'qualityReport', label: 'Quality Report', type: 'textarea' },
                    { name: 'qualityReportDate', label: 'Quality Report Date', type: 'date' }
                ]
            }
        ]
    },
    'INSPIRE': {
        required: ['title', 'abstract', 'resourceType', 'spatialExtent', 'temporalExtent', 'pointOfContact'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'resourceType', label: 'Resource Type', type: 'select', required: true, 
                      options: ['dataset', 'series', 'service'] },
                    { name: 'conformity', label: 'Conformity', type: 'select', required: true,
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['Addresses', 'Administrative units', 'Agricultural and aquaculture facilities', 
                              'Area management/restriction/regulation zones and reporting units', 'Atmospheric conditions', 
                              'Bio-geographical regions', 'Buildings', 'Cadastral parcels', 'Coordinate reference systems', 
                              'Elevation', 'Energy resources', 'Environmental monitoring facilities', 'Geographical grid systems', 
                              'Geographical names', 'Habitats and biotopes', 'Hydrography', 'Land cover', 'Land use', 
                              'Meteorological geographical features', 'Mineral resources', 'Natural risk zones', 
                              'Oceanographic geographical features', 'Orthoimagery', 'Population distribution â€” demography', 
                              'Production and industrial facilities', 'Protected sites', 'Sea regions', 'Soil', 
                              'Species distribution', 'Statistical units', 'Transport networks', 'Utility and governmental services'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map', required: true },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialRepresentationType', label: 'Spatial Representation Type', type: 'select',
                      options: ['vector', 'grid', 'textTable', 'tin', 'stereoModel', 'video'] },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text', required: true },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Responsible Parties',
                fields: [
                    { name: 'pointOfContact', label: 'Point of Contact', type: 'text', required: true },
                    { name: 'pointOfContactRole', label: 'Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'publisherRole', label: 'Publisher Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] },
                    { name: 'metadataPointOfContact', label: 'Metadata Point of Contact', type: 'text' },
                    { name: 'metadataPointOfContactRole', label: 'Metadata Point of Contact Role', type: 'select',
                      options: ['resourceProvider', 'custodian', 'owner', 'user', 'distributor', 'originator', 'pointOfContact', 'principalInvestigator', 'processor', 'publisher', 'author'] }
                ]
            },
            {
                title: 'Data Quality',
                fields: [
                    { name: 'lineage', label: 'Lineage', type: 'textarea' },
                    { name: 'conformity', label: 'Conformity', type: 'select', required: true,
                      options: ['conformant', 'notConformant', 'notEvaluated'] },
                    { name: 'completeness', label: 'Completeness', type: 'textarea' },
                    { name: 'logicalConsistency', label: 'Logical Consistency', type: 'textarea' },
                    { name: 'positionalAccuracy', label: 'Positional Accuracy', type: 'textarea' },
                    { name: 'temporalAccuracy', label: 'Temporal Accuracy', type: 'textarea' },
                    { name: 'thematicAccuracy', label: 'Thematic Accuracy', type: 'textarea' },
                    { name: 'qualityLevel', label: 'Quality Level', type: 'select',
                      options: ['raw', 'processed', 'derived', 'interpreted'] },
                    { name: 'qualityReport', label: 'Quality Report', type: 'textarea' },
                    { name: 'qualityReportDate', label: 'Quality Report Date', type: 'date' }
                ]
            },
            {
                title: 'Distribution',
                fields: [
                    { name: 'distributionFormat', label: 'Distribution Format', type: 'text' },
                    { name: 'distributionUrl', label: 'Distribution URL', type: 'url' },
                    { name: 'distributionAccessConstraints', label: 'Access Constraints', type: 'textarea' },
                    { name: 'distributionUseConstraints', label: 'Use Constraints', type: 'textarea' },
                    { name: 'distributionFormatVersion', label: 'Format Version', type: 'text' },
                    { name: 'distributionSize', label: 'Distribution Size', type: 'text' },
                    { name: 'distributionUnits', label: 'Size Units', type: 'select',
                      options: ['bytes', 'kilobytes', 'megabytes', 'gigabytes', 'terabytes'] },
                    { name: 'distributionTransferOptions', label: 'Transfer Options', type: 'textarea' }
                ]
            },
            {
                title: 'Maintenance',
                fields: [
                    { name: 'maintenanceFrequency', label: 'Maintenance Frequency', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'maintenanceNote', label: 'Maintenance Note', type: 'textarea' },
                    { name: 'maintenanceDate', label: 'Last Maintenance Date', type: 'date' },
                    { name: 'maintenanceScope', label: 'Maintenance Scope', type: 'select',
                      options: ['dataset', 'series', 'featureType', 'feature', 'attributeType', 'attribute', 'tile', 'model', 'other'] }
                ]
            }
        ]
    },
    'OGC CSW': {
        required: ['title', 'abstract', 'type', 'subject', 'format'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'abstract', label: 'Abstract', type: 'textarea', required: true },
                    { name: 'type', label: 'Type', type: 'select', required: true,
                      options: ['dataset', 'series', 'service', 'software', 'other'] },
                    { name: 'subject', label: 'Subject', type: 'text', required: true },
                    { name: 'format', label: 'Format', type: 'text', required: true },
                    { name: 'keywords', label: 'Keywords', type: 'textarea' },
                    { name: 'topicCategory', label: 'Topic Category', type: 'select', 
                      options: ['farming', 'biota', 'boundaries', 'climatologyMeteorologyAtmosphere', 
                              'economy', 'elevation', 'environment', 'geoscientificInformation', 
                              'health', 'imageryBaseMapsEarthCover', 'intelligenceMilitary', 
                              'inlandWaters', 'location', 'oceans', 'planningCadastre', 
                              'society', 'structure', 'transportation', 'utilitiesCommunication'] },
                    { name: 'datasetLanguage', label: 'Dataset Language', type: 'text' },
                    { name: 'characterSet', label: 'Character Set', type: 'select',
                      options: ['ucs2', 'ucs4', 'utf7', 'utf8', 'utf16', '8859part1', '8859part2', '8859part3', '8859part4', '8859part5', '8859part6', '8859part7', '8859part8', '8859part9', '8859part10', '8859part11', '8859part13', '8859part14', '8859part15', '8859part16', 'jis', 'shiftJIS', 'eucJP', 'usAscii', 'ebcdic', 'eucKR', 'big5', 'gb2312'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map' },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialRepresentationType', label: 'Spatial Representation Type', type: 'select',
                      options: ['vector', 'grid', 'textTable', 'tin', 'stereoModel', 'video'] },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' },
                    { name: 'spatialResolutionVertical', label: 'Vertical Resolution', type: 'number' },
                    { name: 'spatialResolutionVerticalUnits', label: 'Vertical Resolution Units', type: 'select',
                      options: ['meters', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            },
            {
                title: 'Additional Information',
                fields: [
                    { name: 'rights', label: 'Rights', type: 'textarea' },
                    { name: 'source', label: 'Source', type: 'text' },
                    { name: 'creator', label: 'Creator', type: 'text' },
                    { name: 'contributor', label: 'Contributor', type: 'text' },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'language', label: 'Language', type: 'text' },
                    { name: 'relation', label: 'Relation', type: 'text' },
                    { name: 'coverage', label: 'Coverage', type: 'text' },
                    { name: 'identifier', label: 'Identifier', type: 'text' },
                    { name: 'modified', label: 'Modified Date', type: 'date' },
                    { name: 'created', label: 'Created Date', type: 'date' },
                    { name: 'valid', label: 'Valid Date', type: 'date' },
                    { name: 'available', label: 'Available Date', type: 'date' },
                    { name: 'issued', label: 'Issued Date', type: 'date' }
                ]
            }
        ]
    },
    'Dublin Core': {
        required: ['title', 'creator', 'subject', 'description'],
        sections: [
            {
                title: 'Basic Information',
                fields: [
                    { name: 'title', label: 'Title', type: 'text', required: true },
                    { name: 'creator', label: 'Creator', type: 'text', required: true },
                    { name: 'subject', label: 'Subject', type: 'text', required: true },
                    { name: 'description', label: 'Description', type: 'textarea', required: true },
                    { name: 'publisher', label: 'Publisher', type: 'text' },
                    { name: 'contributor', label: 'Contributor', type: 'text' },
                    { name: 'date', label: 'Date', type: 'date' },
                    { name: 'type', label: 'Type', type: 'select',
                      options: ['Collection', 'Dataset', 'Event', 'Image', 'InteractiveResource', 'MovingImage', 'PhysicalObject', 'Service', 'Software', 'Sound', 'StillImage', 'Text'] },
                    { name: 'format', label: 'Format', type: 'text' },
                    { name: 'identifier', label: 'Identifier', type: 'text' },
                    { name: 'source', label: 'Source', type: 'text' },
                    { name: 'language', label: 'Language', type: 'text' },
                    { name: 'relation', label: 'Relation', type: 'text' },
                    { name: 'coverage', label: 'Coverage', type: 'text' },
                    { name: 'rights', label: 'Rights', type: 'textarea' },
                    { name: 'audience', label: 'Audience', type: 'text' },
                    { name: 'provenance', label: 'Provenance', type: 'textarea' },
                    { name: 'rightsHolder', label: 'Rights Holder', type: 'text' },
                    { name: 'accrualMethod', label: 'Accrual Method', type: 'select',
                      options: ['deposit', 'purchase', 'inheritance', 'generation', 'integration', 'migration'] },
                    { name: 'accrualPeriodicity', label: 'Accrual Periodicity', type: 'select',
                      options: ['continual', 'daily', 'weekly', 'fortnightly', 'monthly', 'quarterly', 'biannually', 'annually', 'asNeeded', 'irregular', 'notPlanned', 'unknown'] },
                    { name: 'accrualPolicy', label: 'Accrual Policy', type: 'select',
                      options: ['closed', 'open', 'restricted'] }
                ]
            },
            {
                title: 'Spatial Information',
                fields: [
                    { name: 'spatialExtent', label: 'Spatial Extent', type: 'map' },
                    { name: 'crs', label: 'Coordinate Reference System', type: 'text', value: 'EPSG:4326' },
                    { name: 'spatialResolution', label: 'Spatial Resolution', type: 'text' },
                    { name: 'spatialResolutionUnits', label: 'Spatial Resolution Units', type: 'select',
                      options: ['meters', 'degrees', 'feet', 'inches', 'kilometers', 'miles', 'nauticalMiles'] },
                    { name: 'spatialResolutionDistance', label: 'Spatial Resolution Distance', type: 'number' }
                ]
            },
            {
                title: 'Temporal Information',
                fields: [
                    { name: 'temporalExtent', label: 'Temporal Extent', type: 'text' },
                    { name: 'temporalResolution', label: 'Temporal Resolution', type: 'text' },
                    { name: 'timePeriod', label: 'Time Period', type: 'text' },
                    { name: 'temporalReferenceSystem', label: 'Temporal Reference System', type: 'text' },
                    { name: 'temporalResolutionUnits', label: 'Temporal Resolution Units', type: 'select',
                      options: ['years', 'months', 'days', 'hours', 'minutes', 'seconds'] }
                ]
            }
        ]
    }
};

// Function to load template fields
async function loadTemplate(standard) {
    const dynamicFields = document.getElementById('dynamicFields');
    dynamicFields.innerHTML = ''; // Clear existing fields

    if (!standard) {
        return;
    }

    if (standardFields[standard]) {
        renderFields(standardFields[standard].sections);
    } else {
        console.error('Unknown metadata standard:', standard);
        alert('Unknown metadata standard. Please try again.');
    }
}

// Function to group fields into sections
function groupFieldsIntoSections(fields) {
    const sections = {};
    
    fields.forEach(field => {
        const section = field.section || 'Additional Information';
        if (!sections[section]) {
            sections[section] = [];
        }
        sections[section].push(field);
    });

    return Object.entries(sections).map(([title, fields]) => ({
        title,
        fields
    }));
}

// Function to render fields
function renderFields(sections) {
    const dynamicFields = document.getElementById('dynamicFields');
    
    sections.forEach(section => {
        const sectionDiv = document.createElement('div');
        sectionDiv.className = 'metadata-section';
        
        const sectionTitle = document.createElement('h2');
        sectionTitle.className = 'text-xl font-semibold mb-4';
        sectionTitle.textContent = section.title;
        sectionDiv.appendChild(sectionTitle);

        const table = document.createElement('table');
        table.className = 'metadata-table';
        
        section.fields.forEach(field => {
            const row = document.createElement('tr');
            
            const labelCell = document.createElement('th');
            const label = document.createElement('label');
            label.className = 'form-label';
            if (field.required) {
                label.classList.add('required-field');
            }
            label.textContent = field.label;
            label.setAttribute('for', field.name);
            labelCell.appendChild(label);
            row.appendChild(labelCell);

            const inputCell = document.createElement('td');
            let input;
            
            switch (field.type) {
                case 'textarea':
                    input = document.createElement('textarea');
                    input.className = 'form-textarea';
                    break;
                case 'select':
                    input = document.createElement('select');
                    input.className = 'form-select';
                    if (field.options) {
                        field.options.forEach(option => {
                            const opt = document.createElement('option');
                            opt.value = option;
                            opt.textContent = option;
                            input.appendChild(opt);
                        });
                    }
                    break;
                case 'map':
                    // Special handling for map input
                    const mapContainer = document.createElement('div');
                    mapContainer.id = 'map';
                    mapContainer.style.height = '400px';
                    mapContainer.style.marginBottom = '1rem';
                    
                    // Create grid for coordinate inputs
                    const gridContainer = document.createElement('div');
                    gridContainer.className = 'grid grid-cols-2 gap-4 mt-4';
                    
                    // Create coordinate input fields
                    const coordinates = [
                        { id: 'westBound', label: 'West Bound Longitude', name: 'metadata[spatial_extent][coordinates][0][0][0]' },
                        { id: 'eastBound', label: 'East Bound Longitude', name: 'metadata[spatial_extent][coordinates][0][2][0]' },
                        { id: 'southBound', label: 'South Bound Latitude', name: 'metadata[spatial_extent][coordinates][0][0][1]' },
                        { id: 'northBound', label: 'North Bound Latitude', name: 'metadata[spatial_extent][coordinates][0][2][1]' }
                    ];
                    
                    coordinates.forEach(coord => {
                        const div = document.createElement('div');
                        const label = document.createElement('label');
                        label.className = 'form-label';
                        label.textContent = coord.label;
                        label.setAttribute('for', coord.id);
                        
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.id = coord.id;
                        input.name = coord.name;
                        input.step = 'any';
                        input.className = 'form-input';
                        if (field.required) {
                            input.required = true;
                            label.classList.add('required-field');
                        }
                        
                        div.appendChild(label);
                        div.appendChild(input);
                        gridContainer.appendChild(div);
                    });
                    
                    // Add map and grid to a container
                    const container = document.createElement('div');
                    container.appendChild(mapContainer);
                    container.appendChild(gridContainer);
                    input = container;
                    
                    // Initialize map after adding to DOM
                    setTimeout(() => initializeMap(field.name), 0);
                    break;
                default:
                    input = document.createElement('input');
                    input.type = field.type;
                    input.className = 'form-input';
            }

            if (input.tagName !== 'DIV') { // Skip for map container
                input.id = field.name;
                input.name = field.name;
                if (field.required) {
                    input.required = true;
                }
                if (field.value) {
                    input.value = field.value;
                }
            }
            
            inputCell.appendChild(input);
            row.appendChild(inputCell);
            table.appendChild(row);
        });

        sectionDiv.appendChild(table);
        dynamicFields.appendChild(sectionDiv);
    });
}

// Initialize map for spatial extent
function initializeMap(fieldName) {
    // ... existing map initialization code ...
}

// Update form submission handler
async function handleFormSubmit(event) {
    event.preventDefault();
    console.log('Form submission started');

    const form = event.target;
    const formData = new FormData(form);
    
    // Debug log all form data
    console.log('All form data:');
    for (let [key, value] of formData.entries()) {
        console.log(`${key}: ${value}`);
    }
    
    // Get spatial extent values
    const west = document.getElementById('westBound').value;
    const east = document.getElementById('eastBound').value;
    const south = document.getElementById('southBound').value;
    const north = document.getElementById('northBound').value;

    console.log('Spatial extent values before submission:', { west, east, south, north });

    // Remove any existing spatial extent data
    for (let key of formData.keys()) {
        if (key.startsWith('metadata[spatial_extent]')) {
            console.log('Removing existing spatial extent data:', key);
            formData.delete(key);
        }
    }

    // Add spatial extent data in the format expected by the model
    if (west && east && south && north) {
        // Create the spatial extent structure expected by the model
        const spatialExtent = {
            type: 'Polygon',
            coordinates: [[
                [parseFloat(west), parseFloat(south)],
                [parseFloat(west), parseFloat(north)],
                [parseFloat(east), parseFloat(north)],
                [parseFloat(east), parseFloat(south)],
                [parseFloat(west), parseFloat(south)]
            ]]
        };

        // Add the spatial extent as a single JSON string
        formData.append('spatial_extent', JSON.stringify(spatialExtent));
        console.log('Added spatial extent:', spatialExtent);
    } else {
        console.warn('Missing spatial extent values:', { west, east, south, north });
    }

    // Add all spatial metadata fields
    const spatialFields = {
        'crs': document.getElementById('crs')?.value || 'EPSG:4326',
        'crsType': document.getElementById('crsType')?.value || 'geographic',
        'spatialResolution': document.getElementById('spatialResolution')?.value || '',
        'spatialRepresentationType': document.getElementById('spatialRepresentationType')?.value || 'vector',
        'spatialResolutionUnits': document.getElementById('spatialResolutionUnits')?.value || 'meters',
        'spatialResolutionDistance': document.getElementById('spatialResolutionDistance')?.value || '',
        'spatialResolutionVertical': document.getElementById('spatialResolutionVertical')?.value || '',
        'spatialResolutionVerticalUnits': document.getElementById('spatialResolutionVerticalUnits')?.value || 'meters'
    };

    // Add each spatial field to the form data
    Object.entries(spatialFields).forEach(([key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
            formData.append(`metadata[${key}]`, value);
            console.log(`Added spatial field ${key}:`, value);
        }
    });

    // Add temporal information
    const temporalStart = document.getElementById('temporalExtent').value;
    const temporalEnd = document.getElementById('temporalExtentEnd')?.value;
    if (temporalStart) {
        formData.append('temporalStart', temporalStart);
        if (temporalEnd) {
            formData.append('temporalEnd', temporalEnd);
        }
    }

    // Add responsible parties
    const publisher = document.getElementById('publisher').value;
    const pointOfContact = document.getElementById('pointOfContact').value;
    if (publisher) {
        formData.append('publisher', publisher);
    }
    if (pointOfContact) {
        formData.append('pointOfContact', pointOfContact);
    }

    // Add all metadata fields with proper structure
    const metadataFields = {
        'title': document.getElementById('title')?.value || '',
        'abstract': document.getElementById('abstract')?.value || '',
        'keywords': document.getElementById('keywords')?.value?.split(',').map(k => k.trim()) || [],
        'language': document.getElementById('language')?.value || 'eng',
        'characterSet': document.getElementById('characterSet')?.value || 'utf8',
        'topicCategory': document.getElementById('topicCategory')?.value || '',
        'purpose': document.getElementById('purpose')?.value || '',
        'status': document.getElementById('status')?.value || 'completed',
        'updateFrequency': document.getElementById('updateFrequency')?.value || '',
        'accessConstraints': document.getElementById('accessConstraints')?.value || '',
        'useConstraints': document.getElementById('useConstraints')?.value || '',
        'lineage': document.getElementById('lineage')?.value || '',
        'scope': document.getElementById('scope')?.value || '',
        'spatialRepresentationType': document.getElementById('spatialRepresentationType')?.value || 'vector',
        'spatialResolution': document.getElementById('spatialResolution')?.value || '',
        'spatialResolutionUnits': document.getElementById('spatialResolutionUnits')?.value || 'meters',
        'spatialResolutionDistance': document.getElementById('spatialResolutionDistance')?.value || '',
        'spatialResolutionVertical': document.getElementById('spatialResolutionVertical')?.value || '',
        'spatialResolutionVerticalUnits': document.getElementById('spatialResolutionVerticalUnits')?.value || 'meters',
        'crs': document.getElementById('crs')?.value || 'EPSG:4326',
        'crsType': document.getElementById('crsType')?.value || 'geographic'
    };

    // Add each metadata field to the form data
    Object.entries(metadataFields).forEach(([key, value]) => {
        if (value !== null && value !== undefined && value !== '') {
            formData.append(`metadata[${key}]`, Array.isArray(value) ? JSON.stringify(value) : value);
            console.log(`Added metadata field ${key}:`, value);
        }
    });

    try {
        const response = await fetch(form.action, {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: formData
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const result = await response.json();
        console.log('Form submission response:', result);

        if (result.success) {
            window.location.href = result.redirect || '/catalog';
        } else {
            alert(result.message || 'An error occurred while saving the dataset.');
        }
    } catch (error) {
        console.error('Error submitting form:', error);
        alert('An error occurred while saving the dataset. Please try again.');
    }
}

// Handle fetch metadata button click
document.getElementById('fetchMetadataBtn').addEventListener('click', async function(e) {
    e.preventDefault();
    const urlInput = document.getElementById('gis_data_url');
    const urlStatus = document.getElementById('urlStatus');
    const url = urlInput.value.trim();

    console.log('URL input value:', url);

    if (!url) {
        urlStatus.innerHTML = '<span class="text-red-600">Please enter a URL</span>';
        return;
    }

    urlStatus.innerHTML = '<span class="text-blue-600">Fetching metadata...</span>';

    try {
        const response = await fetch('/catalog/fetch-metadata', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify({ url: url })
        });

        console.log('Response status:', response.status);
        const responseText = await response.text();
        console.log('Raw response:', responseText);

        let data = JSON.parse(responseText);
        
        if (!response.ok) {
            throw new Error(data.error || 'Failed to fetch metadata');
        }

        if (!data.metadata) {
            throw new Error('Invalid response format');
        }

        const metadata = data.metadata;
        console.log('Received metadata:', metadata);

        // Helper function to safely set field value
        const setFieldValue = (fieldId, value) => {
            const field = document.getElementById(fieldId);
            if (field) {
                field.value = value || '';
                console.log(`Setting ${fieldId} to:`, value); // Debug log
            } else {
                console.log(`Field not found: ${fieldId}`); // Debug log
            }
        };

        // Update form fields with fetched metadata
        setFieldValue('title', metadata.title);
        setFieldValue('description', metadata.description);
        setFieldValue('abstract', metadata.abstract);
        setFieldValue('keywords', Array.isArray(metadata.keywords) ? metadata.keywords.join(', ') : metadata.keywords);
        setFieldValue('crs', metadata.crs);
        setFieldValue('format', metadata.format);

        // Handle temporal information
        if (metadata.temporal_extent) {
            console.log('Processing temporal extent:', metadata.temporal_extent);
            if (metadata.temporal_extent.start_date) {
                setFieldValue('temporalExtent', metadata.temporal_extent.start_date);
            }
            if (metadata.temporal_extent.end_date) {
                // If we have a separate end date field, set it
                setFieldValue('temporalExtentEnd', metadata.temporal_extent.end_date);
            }
        }

        // Handle responsible parties
        if (metadata.responsible_parties) {
            console.log('Processing responsible parties:', metadata.responsible_parties);
            metadata.responsible_parties.forEach(party => {
                if (party.role === 'publisher') {
                    setFieldValue('publisher', party.name);
                    if (party.role) {
                        setFieldValue('publisherRole', party.role);
                    }
                }
                if (party.role === 'pointOfContact') {
                    setFieldValue('pointOfContact', party.name);
                    if (party.role) {
                        setFieldValue('pointOfContactRole', party.role);
                    }
                }
            });
        }

        // Handle individual responsible party fields if they exist directly in metadata
        if (metadata.publisher) {
            setFieldValue('publisher', metadata.publisher);
        }
        if (metadata.point_of_contact) {
            setFieldValue('pointOfContact', metadata.point_of_contact);
        }

        // Handle spatial extent if available
        if (metadata.spatial_extent && metadata.spatial_extent.coordinates && metadata.spatial_extent.coordinates[0]) {
            console.log('Processing spatial extent:', metadata.spatial_extent);
            
            const coordinates = metadata.spatial_extent.coordinates[0];
            if (coordinates.length >= 4) {
                // First, filter out any invalid coordinates
                const validCoords = coordinates.filter(coord => 
                    !isNaN(coord[0]) && !isNaN(coord[1]) && 
                    coord[0] >= -180 && coord[0] <= 180 &&
                    coord[1] >= -90 && coord[1] <= 90 &&
                    Math.abs(coord[0]) > 1e-10
                );

                console.log('Valid coordinates:', validCoords);

                if (validCoords.length >= 3) { // Need at least 3 points for a valid polygon
                    // Calculate the actual extent from valid coordinates
                    let west = Math.min(...validCoords.map(c => c[0]));
                    let east = Math.max(...validCoords.map(c => c[0]));
                    let south = Math.min(...validCoords.map(c => c[1]));
                    let north = Math.max(...validCoords.map(c => c[1]));

                    console.log('Calculated bounds from valid coordinates:', { west, east, south, north });

                    // If east equals west (which can happen with a single longitude), add a small offset
                    if (Math.abs(east - west) < 1e-10) {
                        east = west + 0.01;
                        console.log('Adjusted east bound to create valid extent:', { west, east });
                    }

                    // Ensure coordinates are in valid ranges
                    west = Math.max(-180, Math.min(180, west));
                    east = Math.max(-180, Math.min(180, east));
                    south = Math.max(-90, Math.min(90, south));
                    north = Math.max(-90, Math.min(90, north));

                    // Ensure east is greater than west
                    if (east <= west) {
                        east = west + 0.01;
                    }

                    console.log('Final validated bounds:', { west, east, south, north });

                    // Update the spatial extent input fields
                    setFieldValue('westBound', west.toFixed(6));
                    setFieldValue('eastBound', east.toFixed(6));
                    setFieldValue('southBound', south.toFixed(6));
                    setFieldValue('northBound', north.toFixed(6));

                    // Update map if available
                    const map = document.getElementById('map');
                    if (map && map.map) {
                        try {
                            // Clear existing extent
                            map.map.getLayers().getArray().forEach(layer => {
                                if (layer instanceof ol.layer.Vector) {
                                    map.map.removeLayer(layer);
                                }
                            });

                            // Create extent feature with validated coordinates
                            const extentFeature = new ol.Feature({
                                geometry: new ol.geom.Polygon([[
                                    [west, south],
                                    [east, south],
                                    [east, north],
                                    [west, north],
                                    [west, south]
                                ]])
                            });

                            // Add vector layer
                            const vectorLayer = new ol.layer.Vector({
                                source: new ol.source.Vector({
                                    features: [extentFeature]
                                }),
                                style: new ol.style.Style({
                                    stroke: new ol.style.Stroke({
                                        color: 'rgba(255, 0, 0, 1.0)',
                                        width: 2
                                    }),
                                    fill: new ol.style.Fill({
                                        color: 'rgba(255, 0, 0, 0.1)'
                                    })
                                })
                            });

                            map.map.addLayer(vectorLayer);
                            map.map.getView().fit(extentFeature.getGeometry().getExtent(), {
                                padding: [50, 50, 50, 50],
                                maxZoom: 10
                            });

                            console.log('Map updated with new extent');
                        } catch (mapError) {
                            console.error('Error updating map:', mapError);
                            urlStatus.innerHTML = '<span class="text-yellow-600">Metadata fetched but map update failed</span>';
                            return;
                        }
                    }
                } else {
                    console.error('Not enough valid coordinates to form a polygon');
                    urlStatus.innerHTML = '<span class="text-red-600">Error: Invalid spatial extent coordinates</span>';
                    return;
                }
            }
        }

        // Handle WMS details if available
        const wmsDetailsSection = document.getElementById('wmsDetailsSection');
        const useWmsCheckbox = document.getElementById('use_wms');
        if (metadata.service_type === 'wms') {
            useWmsCheckbox.checked = true;
            toggleWmsDetails(useWmsCheckbox);
            setFieldValue('wms_url', metadata.service_url || url);
            setFieldValue('wms_layer', metadata.layer_name);
        } else {
            useWmsCheckbox.checked = false;
            toggleWmsDetails(useWmsCheckbox);
        }

        urlStatus.innerHTML = '<span class="text-green-600">Metadata fetched successfully</span>';
    } catch (error) {
        console.error('Error fetching metadata:', error);
        urlStatus.innerHTML = `<span class="text-red-600">Error: ${error.message}</span>`;
    }
});

// Load default template on page load
document.addEventListener('DOMContentLoaded', () => {
    const templateSelect = document.getElementById('metadata_standard');
    if (templateSelect.value) {
        loadTemplate(templateSelect.value);
    } else {
        // Use default fields for selected standard
        const standard = document.getElementById('metadata_standard').value;
        if (standard && standardFields[standard]) {
            renderFields(standardFields[standard].sections);
        }
    }
});

// Add this function to handle WMS details toggle
function toggleWmsDetails(checkbox) {
    const wmsFields = document.getElementById('wmsFields');
    const wmsUrl = document.getElementById('wms_url');
    const wmsLayer = document.getElementById('wms_layer');
    
    if (checkbox.checked) {
        wmsFields.style.display = 'block';
        wmsUrl.required = true;
        wmsLayer.required = true;
    } else {
        wmsFields.style.display = 'none';
        wmsUrl.required = false;
        wmsLayer.required = false;
        wmsUrl.value = '';
        wmsLayer.value = '';
    }
}
</script>
{% endblock %} 